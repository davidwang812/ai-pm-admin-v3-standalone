/**
 * Auth Module - V3 Independent Version
 * ÂÆåÂÖ®Áã¨Á´ãÁöÑV3ËÆ§ËØÅÁÆ°ÁêÜÔºå‰∏ç‰æùËµñRailway
 * Á¨¶ÂêàÂ•ëÁ∫¶Ë¶ÅÊ±ÇÔºöÁã¨Á´ã„ÄÅÂø´ÈÄü„ÄÅÂÆâÂÖ®
 */

export class AuthManagerV3 {
  constructor() {
    console.log('üîê Auth Manager V3 initializing...');
    
    this.tokenKey = 'admin_token_v3';
    this.refreshTokenKey = 'admin_refresh_token_v3';
    this.userKey = 'admin_user_v3';
    
    this.user = null;
    this.token = null;
    this.refreshTimer = null;
    
    // Á´ãÂç≥Ê£ÄÊµãÁéØÂ¢ÉÂπ∂ÊòæÁ§∫APIÁ´ØÁÇπ
    const apiEndpoint = this.getApiEndpoint();
    console.log('‚úÖ Auth Manager initialized with API:', apiEndpoint);
    
    // ÂàùÂßãÂåñÊó∂Âä†ËΩΩÂ≠òÂÇ®ÁöÑËÆ§ËØÅ‰ø°ÊÅØ
    this.loadStoredAuth();
  }

  /**
   * Âä†ËΩΩÂ≠òÂÇ®ÁöÑËÆ§ËØÅ‰ø°ÊÅØ
   */
  loadStoredAuth() {
    try {
      console.log('üîç Loading stored auth...');
      const token = localStorage.getItem(this.tokenKey);
      const userStr = localStorage.getItem(this.userKey);
      
      console.log('üì¶ Token found:', !!token);
      console.log('üì¶ User data found:', !!userStr);
      
      if (token && userStr) {
        this.token = token;
        this.user = JSON.parse(userStr);
        
        console.log('üë§ User loaded:', this.user?.username);
        
        // Ê£ÄÊü•tokenÊòØÂê¶ËøáÊúü
        const expired = this.isTokenExpired();
        console.log('‚è∞ Token expired:', expired);
        
        if (!expired) {
          console.log('‚úÖ Token is valid, setting up auto-refresh');
          this.setupAutoRefresh();
          return true;
        } else {
          console.log('‚ö†Ô∏è Token appears expired, but keeping it for now');
          // ‰∏çÁ´ãÂç≥Ê∏ÖÈô§ÔºåËÆ©checkÊñπÊ≥ïÂÜ≥ÂÆöÊòØÂê¶Âà∑Êñ∞
          return true; // ËøîÂõûtrueÔºåË°®Á§∫ÊúâÂ≠òÂÇ®ÁöÑËÆ§ËØÅ‰ø°ÊÅØ
        }
      }
    } catch (error) {
      console.error('Failed to load stored auth:', error);
    }
    
    console.log('‚ùå No valid stored auth found');
    // Âè™ÊúâÂú®Ê≤°ÊúâtokenÊàñËß£ÊûêÂ§±Ë¥•Êó∂ÊâçÊ∏ÖÈô§
    if (!this.token) {
      this.clearAuth();
    }
    return false;
  }

  /**
   * ÁôªÂΩï - ‰ΩøÁî®V3Áã¨Á´ãËÆ§ËØÅ
   */
  async login(username, password) {
    try {
      console.log('üîê V3 Independent Authentication...');
      
      // Ëé∑ÂèñÊ≠£Á°ÆÁöÑAPIÁ´ØÁÇπ
      const apiEndpoint = this.getApiEndpoint();
      const loginUrl = `${apiEndpoint}/auth/admin/login`;
      
      console.log('üîó Login URL:', loginUrl);
      
      const response = await fetch(loginUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: username,
          password: password
        })
      });
      
      console.log('üì° Response status:', response.status);
      
      const data = await response.json();
      console.log('üì¶ Response data:', data);
      
      if (data.success && data.data) {
        const { user, token, refreshToken } = data.data;
        
        // Â≠òÂÇ®ËÆ§ËØÅ‰ø°ÊÅØ
        this.token = token;
        this.user = user;
        
        localStorage.setItem(this.tokenKey, token);
        localStorage.setItem(this.userKey, JSON.stringify(user));
        
        if (refreshToken) {
          localStorage.setItem(this.refreshTokenKey, refreshToken);
        }
        
        // ËÆæÁΩÆËá™Âä®Âà∑Êñ∞
        this.setupAutoRefresh();
        
        console.log('‚úÖ V3 Login successful:', user.username);
        return {
          success: true,
          user: user,
          redirectUrl: data.data.redirectUrl
        };
      }
      
      return {
        success: false,
        message: data.message || 'Login failed'
      };
      
    } catch (error) {
      console.error('‚ùå V3 Login error:', error);
      return {
        success: false,
        message: error.message || 'Network error'
      };
    }
  }

  /**
   * ÁôªÂá∫
   */
  async logout() {
    try {
      if (this.token) {
        const apiEndpoint = this.getApiEndpoint();
        const logoutUrl = `${apiEndpoint}/auth/admin/logout`;
        
        console.log('üîó Logout URL:', logoutUrl);
        
        await fetch(logoutUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.token}`
          }
        });
      }
    } catch (error) {
      console.warn('Logout API call failed:', error);
    }
    
    // Ê∏ÖÁêÜÊú¨Âú∞ËÆ§ËØÅ‰ø°ÊÅØ
    this.clearAuth();
    
    console.log('üëã V3 Logged out successfully');
    return true;
  }

  /**
   * Ê£ÄÊü•ËÆ§ËØÅÁä∂ÊÄÅ
   */
  async check() {
    console.log('üîê Checking authentication status...');
    
    // Â¶ÇÊûúÊ≤°ÊúâtokenÔºåÂ∞ùËØï‰ªélocalStorageÂä†ËΩΩ
    if (!this.token) {
      console.log('üì¶ No token in memory, loading from storage...');
      const loaded = this.loadStoredAuth();
      if (!loaded) {
        console.log('‚ùå No stored auth found');
        return false;
      }
    }
    
    if (!this.token) {
      console.log('‚ùå Still no token after loading');
      return false;
    }
    
    console.log('üé´ Token present, checking validity...');
    
    // Ê£ÄÊü•tokenÊòØÂê¶ËøáÊúü
    if (this.isTokenExpired()) {
      console.log('üîÑ Token expired, attempting refresh...');
      // Â∞ùËØïÂà∑Êñ∞token
      const refreshed = await this.refreshToken();
      if (!refreshed) {
        console.log('‚ùå Token refresh failed');
        this.clearAuth();
        return false;
      }
      console.log('‚úÖ Token refreshed successfully');
    }
    
    // ÁÆÄÂåñÈ™åËØÅÈÄªËæë - Â¶ÇÊûúÊúâtoken‰∏îÊú™ËøáÊúüÔºåÂ∞±ËÆ§‰∏∫ÊúâÊïà
    // ÈÅøÂÖçÊØèÊ¨°ÈÉΩË∞ÉÁî®ÂêéÁ´ØÈ™åËØÅ
    if (this.token && this.user) {
      console.log('‚úÖ Authentication valid (token and user present)');
      return true;
    }
    
    // Âè™ÊúâÂú®ÂøÖË¶ÅÊó∂ÊâçÈ™åËØÅtoken
    console.log('üîç Verifying token with backend...');
    try {
      const apiEndpoint = this.getApiEndpoint();
      const verifyUrl = `${apiEndpoint}/auth/verify`;
      
      console.log('üîó Verify URL:', verifyUrl);
      
      const response = await fetch(verifyUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.token}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        const valid = data.success === true;
        console.log('üéØ Backend verification result:', valid);
        return valid;
      } else {
        console.log('‚ùå Backend verification failed:', response.status);
      }
    } catch (error) {
      console.error('Token verification error:', error);
      // ÁΩëÁªúÈîôËØØÊó∂ÔºåÂ¶ÇÊûúÊúâtokenÂ∞±ËÆ§‰∏∫ÊúâÊïà
      if (this.token && this.user) {
        console.log('‚ö†Ô∏è Network error, but token exists, treating as valid');
        return true;
      }
    }
    
    return false;
  }

  /**
   * Âà∑Êñ∞Token
   */
  async refreshToken() {
    const refreshToken = localStorage.getItem(this.refreshTokenKey);
    if (!refreshToken) {
      return false;
    }
    
    try {
      console.log('üîÑ V3 Refreshing token...');
      
      const apiEndpoint = this.getApiEndpoint();
      const refreshUrl = `${apiEndpoint}/auth/refresh`;
      
      console.log('üîó Refresh URL:', refreshUrl);
      
      const response = await fetch(refreshUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          refreshToken
        })
      });
      
      const data = await response.json();
      
      if (data.success && data.data) {
        this.token = data.data.token;
        localStorage.setItem(this.tokenKey, data.data.token);
        
        if (data.data.refreshToken) {
          localStorage.setItem(this.refreshTokenKey, data.data.refreshToken);
        }
        
        this.setupAutoRefresh();
        console.log('‚úÖ V3 Token refreshed');
        return true;
      }
    } catch (error) {
      console.error('Failed to refresh token:', error);
    }
    
    return false;
  }

  /**
   * ËÆæÁΩÆËá™Âä®Âà∑Êñ∞
   */
  setupAutoRefresh() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }
    
    // Ëß£ÊûêtokenËé∑ÂèñËøáÊúüÊó∂Èó¥
    const payload = this.parseToken(this.token);
    if (!payload || !payload.exp) {
      return;
    }
    
    // ËÆ°ÁÆóÂà∑Êñ∞Êó∂Èó¥ÔºàËøáÊúüÂâç5ÂàÜÈíüÔºâ
    const expiresAt = payload.exp * 1000;
    const refreshAt = expiresAt - (5 * 60 * 1000);
    const delay = refreshAt - Date.now();
    
    if (delay > 0) {
      console.log(`‚è∞ V3 Auto refresh scheduled in ${Math.round(delay / 1000)}s`);
      this.refreshTimer = setTimeout(() => {
        this.refreshToken();
      }, delay);
    }
  }

  /**
   * Ëß£ÊûêJWT Token
   */
  parseToken(token) {
    if (!token) return null;
    
    try {
      const parts = token.split('.');
      if (parts.length !== 3) return null;
      
      const payload = JSON.parse(atob(parts[1]));
      return payload;
    } catch (error) {
      console.error('Failed to parse token:', error);
      return null;
    }
  }

  /**
   * Ê£ÄÊü•TokenÊòØÂê¶ËøáÊúü
   */
  isTokenExpired() {
    const payload = this.parseToken(this.token);
    if (!payload) {
      console.warn('‚ö†Ô∏è Cannot parse token');
      return true;
    }
    
    if (!payload.exp) {
      console.log('‚ÑπÔ∏è Token has no expiry, treating as valid');
      return false; // Ê≤°ÊúâËøáÊúüÊó∂Èó¥ÁöÑtokenËßÜ‰∏∫Ê∞∏‰∏çËøáÊúü
    }
    
    const now = Date.now();
    const expiry = payload.exp * 1000;
    const timeLeft = expiry - now;
    
    console.log('‚è∞ Token expiry check:');
    console.log('   Current time:', new Date(now).toISOString());
    console.log('   Token expires:', new Date(expiry).toISOString());
    console.log('   Time left:', Math.floor(timeLeft / 1000), 'seconds');
    
    // Áªô5ÂàÜÈíüÁºìÂÜ≤Êó∂Èó¥
    const bufferTime = 5 * 60 * 1000;
    const expired = now >= (expiry - bufferTime);
    
    if (expired) {
      console.log('‚ö†Ô∏è Token is expired or expiring soon');
    } else {
      console.log('‚úÖ Token is still valid');
    }
    
    return expired;
  }

  /**
   * Ê∏ÖÁêÜËÆ§ËØÅ‰ø°ÊÅØ
   */
  clearAuth() {
    this.token = null;
    this.user = null;
    
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.refreshTokenKey);
    localStorage.removeItem(this.userKey);
    
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
  }

  /**
   * Ëé∑ÂèñÂΩìÂâçÁî®Êà∑
   */
  getUser() {
    return this.user;
  }

  /**
   * Ëé∑ÂèñToken
   */
  getToken() {
    return this.token;
  }

  /**
   * Ê£ÄÊü•ÊùÉÈôê
   */
  hasPermission(permission) {
    if (!this.user) return false;
    
    // Ë∂ÖÁ∫ßÁÆ°ÁêÜÂëòÊã•ÊúâÊâÄÊúâÊùÉÈôê
    if (this.user.role === 'super_admin' || this.user.isSuperAdmin) {
      return true;
    }
    
    // Ê£ÄÊü•ÂÖ∑‰ΩìÊùÉÈôê
    if (this.user.permissions && Array.isArray(this.user.permissions)) {
      return this.user.permissions.includes(permission);
    }
    
    return false;
  }

  /**
   * ÊòØÂê¶‰∏∫ÁÆ°ÁêÜÂëò
   */
  isAdmin() {
    return this.user && (this.user.isAdmin || this.user.isSuperAdmin);
  }

  /**
   * Ëé∑ÂèñAPIÁ´ØÁÇπ
   */
  getApiEndpoint() {
    // Ê£ÄÊü•ÊòØÂê¶Âú®VercelÁéØÂ¢É
    const hostname = window.location.hostname;
    const isVercel = hostname.includes('vercel.app');
    const isLocal = hostname === 'localhost' || hostname === '127.0.0.1';
    
    console.log('üåç Environment Detection:');
    console.log('   Hostname:', hostname);
    console.log('   Is Vercel:', isVercel);
    console.log('   Is Local:', isLocal);
    
    let apiEndpoint;
    
    if (isVercel) {
      // VercelÈÉ®ÁΩ≤ÔºåËøûÊé•Âà∞RailwayÂêéÁ´Ø
      apiEndpoint = 'https://aiproductmanager-production.up.railway.app/api';
      console.log('üöÄ Using Railway backend for Vercel deployment');
    } else if (isLocal) {
      // Êú¨Âú∞ÂºÄÂèë
      apiEndpoint = 'http://localhost:3001/api';
      console.log('üè† Using local development server');
    } else {
      // RailwayÈÉ®ÁΩ≤Ôºå‰ΩøÁî®Áõ∏ÂØπË∑ØÂæÑ
      apiEndpoint = '/api';
      console.log('üöÇ Using Railway relative paths');
    }
    
    console.log('üîó Final API Endpoint:', apiEndpoint);
    return apiEndpoint;
  }
}

// ÂàõÂª∫Âçï‰æãÂÆû‰æã
const authManagerV3 = new AuthManagerV3();

// ÂØºÂá∫‰∏∫ÈªòËÆ§
export default authManagerV3;